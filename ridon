import os
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import sqlite3
from sqlite3 import Connection
from contextlib import contextmanager
import json
import math
import random
import asyncio
import uuid

from telegram import (
    Update, 
    InlineKeyboardButton, 
    InlineKeyboardMarkup,
    ReplyKeyboardRemove,
    KeyboardButton,
    ReplyKeyboardMarkup
)
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ConversationHandler,
    ContextTypes,
    filters
)
from telegram.constants import ParseMode


BOT_TOKEN = ""  


ADMIN_IDS = []
DB_PATH = "nearby_bot.db"

MAX_PHOTOS = 3
MAX_BIO_LENGTH = 500
DEFAULT_SEARCH_RADIUS_KM = 50
CHAT_DURATION_HOURS = 24
LIKES_PER_DAY_FREE = 20

class States:
    REG_PHOTO = 1
    REG_NAME_AGE = 2
    REG_GENDER = 3
    REG_CITY = 4
    REG_BIO = 5
    REG_GOAL = 6
    EDIT_PROFILE = 7

class Database:
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.init_db()
    
    @contextmanager
    def get_connection(self):
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
            conn.commit()
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            conn.close()
    
    def init_db(self):
        with self.get_connection() as conn:
            
            conn.execute("""
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    telegram_id INTEGER UNIQUE NOT NULL,
                    username TEXT,
                    full_name TEXT,
                    age INTEGER,
                    city TEXT,
                    latitude REAL,
                    longitude REAL,
                    bio TEXT,
                    goal TEXT,
                    gender TEXT,
                    photos TEXT,  -- JSON —Å–ø–∏—Å–æ–∫ file_id
                    likes_today INTEGER DEFAULT 0,
                    likes_reset_date TEXT,
                    is_active BOOLEAN DEFAULT 1,
                    is_banned BOOLEAN DEFAULT 0,
                    last_seen TEXT,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            
            conn.execute("""
                CREATE TABLE IF NOT EXISTS likes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    from_user_id INTEGER NOT NULL,
                    to_user_id INTEGER NOT NULL,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (from_user_id) REFERENCES users(id),
                    FOREIGN KEY (to_user_id) REFERENCES users(id),
                    UNIQUE(from_user_id, to_user_id)
                )
            """)
            
            
            conn.execute("""
                CREATE TABLE IF NOT EXISTS reports (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    reporter_id INTEGER NOT NULL,
                    reported_user_id INTEGER NOT NULL,
                    reason TEXT,
                    status TEXT DEFAULT 'pending',
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (reporter_id) REFERENCES users(id),
                    FOREIGN KEY (reported_user_id) REFERENCES users(id)
                )
            """)
            
            
            conn.execute("CREATE INDEX IF NOT EXISTS idx_users_telegram ON users(telegram_id)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_users_active ON users(is_active)")
    
    def get_user_by_telegram_id(self, telegram_id: int) -> Optional[Dict]:
        with self.get_connection() as conn:
            cursor = conn.execute("SELECT * FROM users WHERE telegram_id = ?", (telegram_id,))
            row = cursor.fetchone()
            if row:
                user = dict(row)
                
                # –î–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è photos
                if user['photos']:
                    try:
                        user['photos'] = json.loads(user['photos'])
                    except:
                        user['photos'] = []
                else:
                    user['photos'] = []
                return user
            return None
    
    def create_user(self, user_data: Dict) -> Optional[Dict]:
        with self.get_connection() as conn:
            
            data_to_insert = user_data.copy()
            # –°–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è photos
            if 'photos' in data_to_insert and isinstance(data_to_insert['photos'], list):
                data_to_insert['photos'] = json.dumps(data_to_insert['photos'], ensure_ascii=False)
            
            fields = list(data_to_insert.keys())
            placeholders = ['?' for _ in fields]
            
            sql = f"""
                INSERT INTO users ({', '.join(fields)})
                VALUES ({', '.join(placeholders)})
            """
            
            try:
                cursor = conn.execute(sql, list(data_to_insert.values()))
                user_id = cursor.lastrowid
                
                
                cursor = conn.execute("SELECT * FROM users WHERE id = ?", (user_id,))
                row = cursor.fetchone()
                if row:
                    user = dict(row)
                    
                    # –î–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è photos
                    if user['photos']:
                        try:
                            user['photos'] = json.loads(user['photos'])
                        except:
                            user['photos'] = []
                    else:
                        user['photos'] = []
                    return user
            except Exception as e:
                logging.error(f"Error creating user: {e}")
            return None
    
    def update_user(self, telegram_id: int, updates: Dict) -> bool:
        with self.get_connection() as conn:
            
            data_to_update = updates.copy()
            # –°–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è photos
            if 'photos' in data_to_update and isinstance(data_to_update['photos'], list):
                data_to_update['photos'] = json.dumps(data_to_update['photos'], ensure_ascii=False)
            
            set_clause = ', '.join([f"{key} = ?" for key in data_to_update.keys()])
            values = list(data_to_update.values()) + [telegram_id]
            
            sql = f"UPDATE users SET {set_clause} WHERE telegram_id = ?"
            cursor = conn.execute(sql, values)
            return cursor.rowcount > 0
    
    def reset_daily_likes_if_needed(self, user_id: int):
        with self.get_connection() as conn:
            user = self.get_user_by_telegram_id(user_id)
            if not user:
                return
            
            today = datetime.now().strftime("%Y-%m-%d")
            if user.get('likes_reset_date') != today:
                conn.execute(
                    "UPDATE users SET likes_today = 0, likes_reset_date = ? WHERE telegram_id = ?",
                    (today, user_id)
                )
    
    def get_next_profile(self, current_user_id: int) -> Optional[Dict]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ª–µ–¥—É—é—â—É—é –∞–Ω–∫–µ—Ç—É –¥–ª—è –ø–æ–∫–∞–∑–∞"""
        with self.get_connection() as conn:
            user = self.get_user_by_telegram_id(current_user_id)
            if not user:
                return None
            
            user_id_db = user['id']
            
            
            query = """
                SELECT u.* FROM users u
                WHERE u.telegram_id != ?
                AND u.is_active = 1
                AND u.is_banned = 0
                AND NOT EXISTS (
                    SELECT 1 FROM likes l 
                    WHERE l.from_user_id = ?
                    AND l.to_user_id = u.id
                )
                ORDER BY RANDOM()
                LIMIT 1
            """
            
            params = [
                current_user_id,  
                user_id_db
            ]
            
            cursor = conn.execute(query, params)
            row = cursor.fetchone()
            
            if row:
                profile = dict(row)
               
                # –î–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è photos
                if profile['photos']:
                    try:
                        profile['photos'] = json.loads(profile['photos'])
                    except:
                        profile['photos'] = []
                else:
                    profile['photos'] = []
                return profile
            
            return None
    
    def create_like(self, from_user_id: int, to_user_id: int) -> bool:
        """–°–æ–∑–¥–∞—Ç—å –ª–∞–π–∫ –∏ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞ –≤–∑–∞–∏–º–Ω–æ—Å—Ç—å"""
        with self.get_connection() as conn:
           
            from_user = self.get_user_by_telegram_id(from_user_id)
            to_user = db.get_user_by_telegram_id(to_user_id)
            
            if not from_user or not to_user:
                return False
            
           
            today = datetime.now().strftime("%Y-%m-%d")
            if from_user.get('likes_reset_date') != today:
                conn.execute(
                    "UPDATE users SET likes_today = 0, likes_reset_date = ? WHERE telegram_id = ?",
                    (today, from_user_id)
                )
                from_user['likes_today'] = 0
            
            likes_limit = LIKES_PER_DAY_FREE
            if from_user['likes_today'] >= likes_limit:
                return False  
            
           
            try:
                conn.execute(
                    "INSERT OR IGNORE INTO likes (from_user_id, to_user_id) VALUES (?, ?)",
                    (from_user['id'], to_user['id'])
                )
                
                
                conn.execute(
                    "UPDATE users SET likes_today = likes_today + 1 WHERE telegram_id = ?",
                    (from_user_id,)
                )
                
                
                cursor = conn.execute("""
                    SELECT 1 FROM likes 
                    WHERE from_user_id = ? AND to_user_id = ?
                """, (to_user['id'], from_user['id']))
                
                mutual = cursor.fetchone() is not None
                
                return mutual
                
            except Exception as e:
                logging.error(f"Error creating like: {e}")
                return False

db = Database(DB_PATH)


def calculate_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
    """–†–∞—Å—Å—á–∏—Ç–∞—Ç—å —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏ (–∫–º)"""
    if not all([lat1, lon1, lat2, lon2]):
        return 0
    
    
    R = 6371  
    
    lat1_rad = math.radians(lat1)
    lat2_rad = math.radians(lat2)
    delta_lat = math.radians(lat2 - lat1)
    delta_lon = math.radians(lon2 - lon1)
    
    a = math.sin(delta_lat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(delta_lon/2)**2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    
    return R * c


def get_quick_actions_keyboard():
    """–ë—ã—Å—Ç—Ä—ã–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é"""
    return ReplyKeyboardMarkup([
        ["üëÄ –°–º–æ—Ç—Ä–µ—Ç—å –∞–Ω–∫–µ—Ç—ã", "üìä –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å"],
        ["üÜò –ü–æ–º–æ—â—å"]
    ], resize_keyboard=True, one_time_keyboard=False)

def get_profile_quick_actions():
    """–ë—ã—Å—Ç—Ä—ã–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –ø—Ä–æ—Ñ–∏–ª—è"""
    return ReplyKeyboardMarkup([
        ["‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å"],
        ["üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é"]
    ], resize_keyboard=True)

def get_browse_quick_actions():
    """–ë—ã—Å—Ç—Ä—ã–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∞–Ω–∫–µ—Ç"""
    return ReplyKeyboardMarkup([
        ["‚ù§Ô∏è –õ–∞–π–∫", "‚û°Ô∏è –î–∞–ª—å—à–µ"],
        ["üö´ –ü–æ–∂–∞–ª–æ–≤–∞—Ç—å—Å—è", "üîô –í –º–µ–Ω—é"]
    ], resize_keyboard=True)

def get_gender_keyboard():
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ –ø–æ–ª–∞"""
    return ReplyKeyboardMarkup([
        ["üë® –ú–£–ñ–ß–ò–ù–ê", "üë© –ñ–ï–ù–©–ò–ù–ê"]
    ], resize_keyboard=True, one_time_keyboard=True)

def get_goal_keyboard():
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ü–µ–ª–∏"""
    return ReplyKeyboardMarkup([
        ["üíë –û–¢–ù–û–®–ï–ù–ò–Ø"],
        ["üë• –î–†–£–ñ–ë–ê"],
        ["üí¨ –û–ë–©–ï–ù–ò–ï"],
        ["üéâ –ù–ï–í–ê–ñ–ù–û"]
    ], resize_keyboard=True, one_time_keyboard=True)


async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
    user = update.effective_user
    db_user = db.get_user_by_telegram_id(user.id)
    
    if db_user:
        
        reply_markup = get_quick_actions_keyboard()
        
        await update.message.reply_text(
            f"üî• *–° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º, {db_user['full_name'] or user.first_name}!*\n\n"
            "–ò—Å–ø–æ–ª—å–∑—É–π –±—ã—Å—Ç—Ä—ã–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏:",
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
        
        return States.REG_PHOTO
    else:
        
        await update.message.reply_text(
            "üî• *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –†–Ø–î–û–ú!*\n\n"
            "–ó–Ω–∞–∫–æ–º—Å—Ç–≤–∞ —Ä—è–¥–æ–º —Å —Ç–æ–±–æ–π ‚Ä¢ –ë—ã—Å—Ç—Ä–æ ‚Ä¢ –ë–µ–∑–æ–ø–∞—Å–Ω–æ ‚Ä¢ –ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ\n\n"
            "üìù –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–π–º–µ—Ç –≤—Å–µ–≥–æ 2 –º–∏–Ω—É—Ç—ã!\n\n"
            "üì∏ *–®–ê–ì 1: –§–û–¢–û*\n\n"
            "–û—Ç–ø—Ä–∞–≤—å —Å–≤–æ–µ —Ñ–æ—Ç–æ (–ª–∏—Ü–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Ö–æ—Ä–æ—à–æ –≤–∏–¥–Ω–æ):\n\n"
            "‚ö°Ô∏è –°–æ–≤–µ—Ç: –ò—Å–ø–æ–ª—å–∑—É–π —Å–≤–µ–∂–µ–µ –∏ –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ —Ñ–æ—Ç–æ\n"
            "‚ö†Ô∏è –§–æ—Ç–æ –ø—Ä–æ—Ö–æ–¥–∏—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –º–æ–¥–µ—Ä–∞—Ü–∏—é",
            parse_mode=ParseMode.MARKDOWN
        )
        
        return States.REG_PHOTO

async def handle_registration_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ç–æ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏"""
    if not update.message.photo:
        await update.message.reply_text("üì∏ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å —Ñ–æ—Ç–æ.")
        return States.REG_PHOTO
    
    
    photo_file = await update.message.photo[-1].get_file()
    context.user_data['registration'] = {
        'photos': [photo_file.file_id],
        'step': 1
    }
    
    await update.message.reply_text(
        "‚úÖ *–§–æ—Ç–æ –ø—Ä–∏–Ω—è—Ç–æ!*\n\n"
        "üë§ *–®–ê–ì 2: –ò–ú–Ø –ò –í–û–ó–†–ê–°–¢*\n\n"
        "–í–≤–µ–¥–∏ —Å–≤–æ–µ –∏–º—è –∏ –≤–æ–∑—Ä–∞—Å—Ç:\n"
        "*–ü—Ä–∏–º–µ—Ä: –ò–≤–∞–Ω 25* –∏–ª–∏ *–ê–Ω–Ω–∞ 22*\n\n"
        "‚ö°Ô∏è –ü–∏—à–∏ –∫–∞–∫ –≤ –ø—Ä–∏–º–µ—Ä–µ –≤—ã—à–µ",
        parse_mode=ParseMode.MARKDOWN
    )
    
    return States.REG_NAME_AGE

async def handle_registration_name_age(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–º–µ–Ω–∏ –∏ –≤–æ–∑—Ä–∞—Å—Ç–∞"""
    try:
        text = update.message.text.strip()
        parts = text.split()
        
        if len(parts) < 2:
            raise ValueError
        
        name = ' '.join(parts[:-1])
        age = int(parts[-1])
        
        if not 18 <= age <= 100:
            await update.message.reply_text("‚ùå –í–æ–∑—Ä–∞—Å—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 18 –¥–æ 100 –ª–µ—Ç.")
            return States.REG_NAME_AGE
        
        if 'registration' not in context.user_data:
            context.user_data['registration'] = {}
        
        context.user_data['registration']['name'] = name
        context.user_data['registration']['age'] = age
        
        reply_markup = get_gender_keyboard()
        
        await update.message.reply_text(
            "üë´ *–®–ê–ì 3: –ü–û–õ*\n\n"
            "–í—ã–±–µ—Ä–∏ —Å–≤–æ–π –ø–æ–ª:\n\n"
            "‚ö°Ô∏è –≠—Ç–æ –ø–æ–º–æ–∂–µ—Ç –Ω–∞–º –ª—É—á—à–µ –ø–æ–¥–±–∏—Ä–∞—Ç—å –∞–Ω–∫–µ—Ç—ã",
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )
        
        return States.REG_GENDER
        
    except (ValueError, IndexError):
        await update.message.reply_text(
            "‚ùå *–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç!*\n\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ: *–ò–º—è –í–æ–∑—Ä–∞—Å—Ç*\n"
            "–ü—Ä–∏–º–µ—Ä: *–ê–Ω–Ω–∞ 24* –∏–ª–∏ *–ò–≤–∞–Ω –ü–µ—Ç—Ä–æ–≤ 30*",
            parse_mode=ParseMode.MARKDOWN
        )
        return States.REG_NAME_AGE

async def handle_registration_gender(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ –ø–æ–ª–∞"""
    gender_text = update.message.text
    
    gender_map = {
        'üë® –ú–£–ñ–ß–ò–ù–ê': 'male',
        'üë© –ñ–ï–ù–©–ò–ù–ê': 'female'
    }
    
    if gender_text not in gender_map:
        reply_markup = get_gender_keyboard()
        await update.message.reply_text(
            "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏ –ø–æ–ª –∏–∑ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤:",
            reply_markup=reply_markup
        )
        return States.REG_GENDER
    
    if 'registration' not in context.user_data:
        context.user_data['registration'] = {}
    
    context.user_data['registration']['gender'] = gender_map[gender_text]
    
    
    reply_markup = ReplyKeyboardMarkup([
        ["üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é"],
        ["üèôÔ∏è –í–≤–µ—Å—Ç–∏ –≤—Ä—É—á–Ω—É—é"]
    ], resize_keyboard=True, one_time_keyboard=True)
    
    await update.message.reply_text(
        "üìç *–®–ê–ì 4: –ì–û–†–û–î*\n\n"
        "–û—Ç–ø—Ä–∞–≤—å —Å–≤–æ–π –≥–æ—Ä–æ–¥ –∏–ª–∏ –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é:\n\n"
        "‚ö°Ô∏è –ú–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ\n"
        "üìç –ò–ª–∏ –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –≥–æ—Ä–æ–¥–∞",
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )
    
    return States.REG_CITY

async def handle_registration_city(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ—Ä–æ–¥–∞"""
    city = None
    
    if update.message.text == "üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é":
        await update.message.reply_text(
            "üìç –ù–∞–∂–º–∏ –Ω–∞ —Å–∫—Ä–µ–ø–∫—É üìé –∏ –≤—ã–±–µ—Ä–∏ '–ì–µ–æ–ø–æ–∑–∏—Ü–∏—è'",
            reply_markup=ReplyKeyboardRemove()
        )
        return States.REG_CITY
    elif update.message.text == "üèôÔ∏è –í–≤–µ—Å—Ç–∏ –≤—Ä—É—á–Ω—É—é":
        await update.message.reply_text(
            "üèôÔ∏è –ù–∞–ø–∏—à–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å–≤–æ–µ–≥–æ –≥–æ—Ä–æ–¥–∞:",
            reply_markup=ReplyKeyboardRemove()
        )
        return States.REG_CITY
    elif update.message.text:
        city = update.message.text.strip()
    elif update.message.location:
        
        latitude = update.message.location.latitude
        longitude = update.message.location.longitude
        if 'registration' not in context.user_data:
            context.user_data['registration'] = {}
        context.user_data['registration']['latitude'] = latitude
        context.user_data['registration']['longitude'] = longitude
        city = "–ì–æ—Ä–æ–¥ –ø–æ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏"
    
    if not city:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å –Ω–∞–∑–≤–∞–Ω–∏–µ –≥–æ—Ä–æ–¥–∞ –∏–ª–∏ –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é.")
        return States.REG_CITY
    
    if 'registration' not in context.user_data:
        context.user_data['registration'] = {}
    
    context.user_data['registration']['city'] = city
    
    await update.message.reply_text(
        "üìù *–®–ê–ì 5: –û –°–ï–ë–ï*\n\n"
        "–†–∞—Å—Å–∫–∞–∂–∏ –∫–æ—Ä–æ—Ç–∫–æ –æ —Å–µ–±–µ:\n\n"
        "‚ö°Ô∏è *–ü—Ä–∏–º–µ—Ä—ã:*\n"
        "‚Ä¢ –õ—é–±–ª—é –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è, –∫–∏–Ω–æ –∏ –∫–æ—Ñ–µ\n"
        "‚Ä¢ IT-—Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç, —É–≤–ª–µ–∫–∞—é—Å—å —Å–ø–æ—Ä—Ç–æ–º\n"
        "‚Ä¢ –ò—â—É –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–≥–æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞\n\n"
        "üìç –ü–∏—à–∏ –∫—Ä–∞—Ç–∫–æ, –Ω–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ (–¥–æ 500 —Å–∏–º–≤–æ–ª–æ–≤)",
        parse_mode=ParseMode.MARKDOWN
    )
    
    return States.REG_BIO

async def handle_registration_bio(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–µ–±–µ"""
    bio = update.message.text.strip()
    
    if len(bio) > MAX_BIO_LENGTH:
        await update.message.reply_text(f"‚ùå –°–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ! –ú–∞–∫—Å–∏–º—É–º {MAX_BIO_LENGTH} —Å–∏–º–≤–æ–ª–æ–≤.")
        return States.REG_BIO
    
    if 'registration' not in context.user_data:
        context.user_data['registration'] = {}
    
    context.user_data['registration']['bio'] = bio
    
    reply_markup = get_goal_keyboard()
    
    await update.message.reply_text(
        "üéØ *–®–ê–ì 6: –¶–ï–õ–¨*\n\n"
        "–ß—Ç–æ —Ç—ã –∏—â–µ—à—å?\n\n"
        "‚ö°Ô∏è *–í–∞—Ä–∏–∞–Ω—Ç—ã:*\n"
        "‚Ä¢ üíë –û—Ç–Ω–æ—à–µ–Ω–∏—è - –¥–ª—è —Å–µ—Ä—å–µ–∑–Ω—ã—Ö –∑–Ω–∞–∫–æ–º—Å—Ç–≤\n"
        "‚Ä¢ üë• –î—Ä—É–∂–±–∞ - –Ω–∞–π—Ç–∏ –¥—Ä—É–∑–µ–π –∏ –∫–æ–º–ø–∞–Ω–∏—é\n"
        "‚Ä¢ üí¨ –û–±—â–µ–Ω–∏–µ - –ø—Ä–æ—Å—Ç–æ –ø–æ–æ–±—â–∞—Ç—å—Å—è\n"
        "‚Ä¢ üéâ –ù–µ–≤–∞–∂–Ω–æ - –æ—Ç–∫—Ä—ã—Ç –∫–æ –≤—Å–µ–º—É",
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )
    
    return States.REG_GOAL

async def handle_registration_goal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ —Ü–µ–ª–∏"""
    goal_text = update.message.text
    
    goal_map = {
        'üíë –û–¢–ù–û–®–ï–ù–ò–Ø': 'relationship',
        'üë• –î–†–£–ñ–ë–ê': 'friendship',
        'üí¨ –û–ë–©–ï–ù–ò–ï': 'chat',
        'üéâ –ù–ï–í–ê–ñ–ù–û': 'all'
    }
    
    if goal_text not in goal_map:
        reply_markup = get_goal_keyboard()
        await update.message.reply_text(
            "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏ —Ü–µ–ª—å –∏–∑ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤:",
            reply_markup=reply_markup
        )
        return States.REG_GOAL
    
    if 'registration' not in context.user_data:
        context.user_data['registration'] = {}
    
    context.user_data['registration']['goal'] = goal_map[goal_text]
    
    
    reg_data = context.user_data['registration']
    
    user_data = {
        'telegram_id': update.effective_user.id,
        'username': update.effective_user.username,
        'full_name': reg_data.get('name', update.effective_user.full_name),
        'age': reg_data.get('age'),
        'city': reg_data.get('city', '–ù–µ —É–∫–∞–∑–∞–Ω'),
        'bio': reg_data.get('bio', ''),
        'goal': reg_data.get('goal', 'all'),
        'gender': reg_data.get('gender', 'male'),
        'photos': reg_data.get('photos', []),
        'last_seen': datetime.now().isoformat(),
        'likes_reset_date': datetime.now().strftime("%Y-%m-%d")
    }
    
    
    if 'latitude' in reg_data:
        user_data['latitude'] = reg_data['latitude']
    if 'longitude' in reg_data:
        user_data['longitude'] = reg_data['longitude']
    
    try:
        db_user = db.create_user(user_data)
        
        if db_user:
            
            context.user_data.pop('registration', None)
            
            
            reply_markup = get_quick_actions_keyboard()
            
            await update.message.reply_text(
                f"üéâ *–†–ï–ì–ò–°–¢–†–ê–¶–ò–Ø –ó–ê–í–ï–†–®–ï–ù–ê!*\n\n"
                f"üî• –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, {user_data['full_name']}!\n\n"
                f"üìä *–¢–í–û–ô –ü–†–û–§–ò–õ–¨:*\n"
                f"‚Ä¢ üë§ {user_data['full_name']}, {user_data['age']}\n"
                f"‚Ä¢ üìç {user_data['city']}\n"
                f"‚Ä¢ üéØ {user_data['goal']}\n\n"
                f"‚ö°Ô∏è *–°–¢–ê–¢–ò–°–¢–ò–ö–ê:*\n"
                f"‚Ä¢ ‚ù§Ô∏è {LIKES_PER_DAY_FREE} –ª–∞–π–∫–æ–≤ –≤ –¥–µ–Ω—å\n\n"
                f"üìç *–°–æ–≤–µ—Ç:* –ó–∞–ø–æ–ª–Ω–∏ –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–¥—Ä–æ–±–Ω–µ–µ –≤ —Ä–∞–∑–¥–µ–ª–µ '–ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å'",
                parse_mode=ParseMode.MARKDOWN
            )
            
            
            await update.message.reply_text(
                "üéØ *–ò—Å–ø–æ–ª—å–∑—É–π –±—ã—Å—Ç—Ä—ã–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏:*",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
        else:
            await update.message.reply_text(
                "‚ùå *–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è*\n\n"
                "–ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞: /start",
                parse_mode=ParseMode.MARKDOWN
            )
        
        return ConversationHandler.END
        
    except Exception as e:
        logging.error(f"Error creating user: {e}")
        await update.message.reply_text(
            "‚ùå *–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏*\n\n"
            "–ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞: /start",
            parse_mode=ParseMode.MARKDOWN
        )
        return ConversationHandler.END

async def browse_profiles_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∞–Ω–∫–µ—Ç"""
    user = db.get_user_by_telegram_id(update.effective_user.id)
    if not user:
        await update.message.reply_text("‚ùå –°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Å—è: /start")
        return
    
    
    await show_next_profile(update, context)

async def show_next_profile(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–æ–∫–∞–∑–∞—Ç—å —Å–ª–µ–¥—É—é—â—É—é –∞–Ω–∫–µ—Ç—É"""
    user = db.get_user_by_telegram_id(update.effective_user.id)
    if not user:
        return
    
    
    db.reset_daily_likes_if_needed(user['telegram_id'])
    
    
    profile = db.get_next_profile(user['telegram_id'])
    
    if not profile:
        reply_markup = get_browse_quick_actions()
        await update.message.reply_text(
            "üòî *–ü–û–ö–ê –ù–ï–¢ –ü–û–î–•–û–î–Ø–©–ò–• –ê–ù–ö–ï–¢*\n\n"
            "‚ö°Ô∏è *–ü–æ–ø—Ä–æ–±—É–π:*\n"
            "‚Ä¢ –ó–∞–π—Ç–∏ –ø–æ–∑–∂–µ\n\n"
            "üî• –ù–æ–≤—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –ø–æ—è–≤–ª—è—é—Ç—Å—è –∫–∞–∂–¥—ã–π –¥–µ–Ω—å!",
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )
        return
    
    
    caption = f"üî• *{profile['full_name']}, {profile['age']}*\n"
    
    if profile['city']:
        caption += f"üìç {profile['city']}\n"
    
    if profile['bio']:
        bio_preview = profile['bio'][:100] + "..." if len(profile['bio']) > 100 else profile['bio']
        caption += f"\nüìù {bio_preview}\n"
    
    
    if user.get('latitude') and profile.get('latitude'):
        distance = calculate_distance(
            user['latitude'], user['longitude'],
            profile['latitude'], profile['longitude']
        )
        if distance > 0:
            if distance < 1:
                caption += f"\nüìç *–ú–µ–Ω–µ–µ 1 –∫–º –æ—Ç —Ç–µ–±—è*"
            else:
                caption += f"\nüìç *–û–∫–æ–ª–æ {int(distance)} –∫–º –æ—Ç —Ç–µ–±—è*"
    
    reply_markup = get_browse_quick_actions()
    
    
    context.user_data['current_profile_id'] = profile['telegram_id']
    
    
    if profile['photos']:
        photo = profile['photos'][0]
        
        await update.message.reply_photo(
            photo=photo,
            caption=caption,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )
    else:
        await update.message.reply_text(
            caption,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )

async def handle_like_action(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ª–∞–π–∫–∞"""
    user = db.get_user_by_telegram_id(update.effective_user.id)
    if not user:
        return
    
    target_user_id = context.user_data.get('current_profile_id')
    if not target_user_id:
        await update.message.reply_text("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–∞ —Ç–µ–∫—É—â–∞—è –∞–Ω–∫–µ—Ç–∞.")
        return
    
    
    is_mutual = db.create_like(user['telegram_id'], target_user_id)
    
    if is_mutual:
        await update.message.reply_text(
            "üéâ *–ï–°–¢–¨ –í–ó–ê–ò–ú–ù–ê–Ø –°–ò–ú–ü–ê–¢–ò–Ø!*\n\n"
            f"üî• –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –Ω–∞—á–∞—Ç—å –æ–±—â–µ–Ω–∏–µ!"
        )
    else:
        await update.message.reply_text(
            "‚úÖ *–õ–ê–ô–ö –û–¢–ü–†–ê–í–õ–ï–ù!*"
        )
    
    
    await asyncio.sleep(1)
    await show_next_profile(update, context)

async def handle_next_action(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ —Å–ª–µ–¥—É—é—â–µ–π –∞–Ω–∫–µ—Ç–µ"""
    await update.message.reply_text("üîÑ –ò—â–µ–º —Å–ª–µ–¥—É—é—â—É—é –∞–Ω–∫–µ—Ç—É...")
    await show_next_profile(update, context)

async def handle_report_action(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∂–∞–ª–æ–±—ã"""
    await update.message.reply_text(
        "üö´ *–ñ–ê–õ–û–ë–ê*\n\n"
        "–û–ø–∏—à–∏ –ø—Ä–∏—á–∏–Ω—É –∂–∞–ª–æ–±—ã –Ω–∞ —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:"
    )
    
    context.user_data['reporting'] = True
    context.user_data['reported_user_id'] = context.user_data.get('current_profile_id')

async def handle_report_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ –∂–∞–ª–æ–±—ã"""
    if context.user_data.get('reporting'):
        reason = update.message.text
        reported_user_id = context.user_data.get('reported_user_id')
        
        if reported_user_id:
            with db.get_connection() as conn:
                reporter = db.get_user_by_telegram_id(update.effective_user.id)
                reported = db.get_user_by_telegram_id(reported_user_id)
                
                if reporter and reported:
                    conn.execute(
                        "INSERT INTO reports (reporter_id, reported_user_id, reason) VALUES (?, ?, ?)",
                        (reporter['id'], reported['id'], reason)
                    )
                    
                    await update.message.reply_text(
                        "‚úÖ *–ñ–∞–ª–æ–±–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.*\n\n"
                        "–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–º–æ—â—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏–∏ —Å–æ–æ–±—â–µ—Å—Ç–≤–∞!"
                    )
        
        context.user_data.pop('reporting', None)
        context.user_data.pop('reported_user_id', None)
        
        
        await show_next_profile(update, context)

async def profile_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –ø—Ä–æ—Ñ–∏–ª—è"""
    user = db.get_user_by_telegram_id(update.effective_user.id)
    if not user:
        await update.message.reply_text("‚ùå –°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Å—è: /start")
        return
    
    
    text = f"üìä *–¢–í–û–ô –ü–†–û–§–ò–õ–¨*\n\n"
    text += f"üî• *{user['full_name']}, {user['age']}*\n"
    text += f"üìç {user['city'] or '–ì–æ—Ä–æ–¥ –Ω–µ —É–∫–∞–∑–∞–Ω'}\n"
    text += f"üéØ –¶–µ–ª—å: {user['goal'] or '–ù–µ —É–∫–∞–∑–∞–Ω–∞'}\n\n"
    
    if user['bio']:
        text += f"*–û –°–ï–ë–ï:*\n{user['bio']}\n\n"
    
    
    likes_today = user.get('likes_today', 0)
    likes_limit = LIKES_PER_DAY_FREE
    
    text += f"‚ö°Ô∏è *–°–¢–ê–¢–ò–°–¢–ò–ö–ê:*\n"
    text += f"‚Ä¢ ‚ù§Ô∏è –õ–∞–π–∫–æ–≤ —Å–µ–≥–æ–¥–Ω—è: {likes_today}/{likes_limit}\n"
    text += f"‚Ä¢ üî• –ê–∫—Ç–∏–≤–µ–Ω: {'‚úÖ –î–ê' if user['is_active'] else '‚ùå –ù–ï–¢'}\n\n"
    
    reply_markup = get_profile_quick_actions()
    
    
    if user['photos']:
        photo = user['photos'][0]
        
        await update.message.reply_photo(
            photo=photo,
            caption=text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )
    else:
        await update.message.reply_text(
            text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )

async def main_menu_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–í–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"""
    user = db.get_user_by_telegram_id(update.effective_user.id)
    
    reply_markup = get_quick_actions_keyboard()
    
    if user:
        await update.message.reply_text(
            f"üî• *–ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ*\n\n"
            f"–ü—Ä–∏–≤–µ—Ç, {user['full_name'] or '–¥—Ä—É–≥'}!\n\n"
            f"‚ö°Ô∏è *–°—Ç–∞—Ç—É—Å:* –ë–ê–ó–û–í–´–ô\n"
            f"‚ù§Ô∏è –õ–∞–π–∫–æ–≤ —Å–µ–≥–æ–¥–Ω—è: {user.get('likes_today', 0)}/{LIKES_PER_DAY_FREE}\n\n"
            f"üéØ *–ß—Ç–æ –¥–µ–ª–∞–µ–º?*",
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )
    else:
        await update.message.reply_text(
            "üî• *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –†–Ø–î–û–ú!*\n\n"
            "–ó–Ω–∞–∫–æ–º—Å—Ç–≤–∞ —Ä—è–¥–æ–º —Å —Ç–æ–±–æ–π ‚Ä¢ –ë—ã—Å—Ç—Ä–æ ‚Ä¢ –ë–µ–∑–æ–ø–∞—Å–Ω–æ ‚Ä¢ –ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ\n\n"
            "üìù –ù–∞—á–Ω–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å!\n\n"
            "–ù–∞–ø–∏—à–∏ /start –¥–ª—è –Ω–∞—á–∞–ª–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏"
        )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /help"""
    help_text = """
    ü§ñ *–ë–û–¢ –î–õ–Ø –ó–ù–ê–ö–û–ú–°–¢–í ¬´–†–Ø–î–û–ú¬ª*

    ‚ö°Ô∏è *–û–°–ù–û–í–ù–´–ï –ö–û–ú–ê–ù–î–´:*
    /start - –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
    /profile - –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å
    /browse - –ù–∞—á–∞—Ç—å –ø—Ä–æ—Å–º–æ—Ç—Ä –∞–Ω–∫–µ—Ç
    /help - –≠—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞

    üéØ *–ö–ê–ö –≠–¢–û –†–ê–ë–û–¢–ê–ï–¢?*
    1. üìù –ó–∞–ø–æ–ª–Ω–∏ –ø—Ä–æ—Ñ–∏–ª—å (/start)
    2. üëÄ –°–º–æ—Ç—Ä–∏ –∞–Ω–∫–µ—Ç—ã –∏ —Å—Ç–∞–≤—å ‚ù§Ô∏è
    3. üî• –ü—Ä–∏ –≤–∑–∞–∏–º–Ω–æ–π —Å–∏–º–ø–∞—Ç–∏–∏ –º–æ–∂–µ—Ç–µ –Ω–∞—á–∞—Ç—å –æ–±—â–µ–Ω–∏–µ!

    ‚≠ê *–ü–†–ï–ò–ú–£–©–ï–°–¢–í–ê:*
    ‚Ä¢ üìç –ì–µ–æ–ª–æ–∫–∞—Ü–∏–æ–Ω–Ω—ã–π –ø–æ–∏—Å–∫
    ‚Ä¢ ‚ö°Ô∏è –ë—ã—Å—Ç—Ä—ã–µ –∑–Ω–∞–∫–æ–º—Å—Ç–≤–∞

    ‚ö†Ô∏è *–ü–†–ê–í–ò–õ–ê:*
    ‚Ä¢ üôè –ë—É–¥—å –≤–µ–∂–ª–∏–≤ –∏ —É–≤–∞–∂–∏—Ç–µ–ª–µ–Ω
    ‚Ä¢ üö´ –ù–µ —Å–ø–∞–º—å
    ‚Ä¢ üîí –ù–µ –ø–µ—Ä–µ–¥–∞–≤–∞–π –ª–∏—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å—Ä–∞–∑—É
    ‚Ä¢ üì¢ –°–æ–æ–±—â–∞–π –æ –Ω–∞—Ä—É—à–µ–Ω–∏—è—Ö

    üìû *–ü–û–î–î–ï–†–ñ–ö–ê:* @Tseerber
    """
    
    await update.message.reply_text(help_text, parse_mode=ParseMode.MARKDOWN)

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """–û—Ç–º–µ–Ω–∞ —Ç–µ–∫—É—â–µ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è"""
    await update.message.reply_text(
        "‚ùå –î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.",
        reply_markup=ReplyKeyboardRemove()
    )
    return ConversationHandler.END

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫"""
    logging.error(f"Exception while handling an update: {context.error}")
    
    try:
        await context.bot.send_message(
            chat_id=update.effective_chat.id if update else None,
            text="‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞."
        )
    except:
        pass


async def handle_quick_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –±—ã—Å—Ç—Ä—ã—Ö –∫–Ω–æ–ø–æ–∫"""
    text = update.message.text
    
    if text == "üëÄ –°–º–æ—Ç—Ä–µ—Ç—å –∞–Ω–∫–µ—Ç—ã":
        await browse_profiles_command(update, context)
    elif text == "üìä –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å":
        await profile_command(update, context)
    elif text == "üÜò –ü–æ–º–æ—â—å":
        await help_command(update, context)
    elif text == "‚ù§Ô∏è –õ–∞–π–∫":
        await handle_like_action(update, context)
    elif text == "‚û°Ô∏è –î–∞–ª—å—à–µ":
        await handle_next_action(update, context)
    elif text == "üö´ –ü–æ–∂–∞–ª–æ–≤–∞—Ç—å—Å—è":
        await handle_report_action(update, context)
    elif text == "üîô –í –º–µ–Ω—é" or text == "üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é":
        await update.message.reply_text("‚ö°Ô∏è –í–æ–∑–≤—Ä–∞—â–∞—é –≤ –º–µ–Ω—é...", reply_markup=get_quick_actions_keyboard())
        await main_menu_command(update, context)
    elif text == "‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å":
        await update.message.reply_text("‚úèÔ∏è *–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è*\n\n–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ. –°–∫–æ—Ä–æ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–∞!", parse_mode=ParseMode.MARKDOWN)
    else:
        
        if context.user_data.get('reporting'):
            await handle_report_text(update, context)
        else:
            
            await update.message.reply_text(
                "–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –∏–ª–∏ –∫–æ–º–∞–Ω–¥—ã:\n"
                "/start - –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n"
                "/help - –ü–æ–º–æ—â—å"
            )


def main():
    """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
    
    logging.basicConfig(
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        level=logging.INFO
    )
    
    
    if BOT_TOKEN == "–í–°–¢–ê–í–¨–¢–ï_–í–ê–®_–¢–û–ö–ï–ù_–ó–î–ï–°–¨":
        print("‚ùå –û–®–ò–ë–ö–ê: –í—ã –Ω–µ —É–∫–∞–∑–∞–ª–∏ —Ç–æ–∫–µ–Ω –±–æ—Ç–∞!")
        print("üìù –ü–æ–ª—É—á–∏—Ç–µ —Ç–æ–∫–µ–Ω —É @BotFather –≤ Telegram")
        print("üîß –ó–∞–º–µ–Ω–∏—Ç–µ —Å—Ç—Ä–æ–∫—É: BOT_TOKEN = '–í–°–¢–ê–í–¨–¢–ï_–í–ê–®_–¢–û–ö–ï–ù_–ó–î–ï–°–¨'")
        print("   –Ω–∞ –≤–∞—à —Ä–µ–∞–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω, –Ω–∞–ø—Ä–∏–º–µ—Ä:")
        print("   BOT_TOKEN = '8524498297:AAE07uhhKek7jg7gwNyMeGHA_oDJCgWXvns'")
        return
    
    
    application = Application.builder().token(BOT_TOKEN).build()
    
   
    application.add_error_handler(error_handler)
    
    
    registration_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", start_command)
        ],
        states={
            States.REG_PHOTO: [
                MessageHandler(filters.PHOTO, handle_registration_photo)
            ],
            States.REG_NAME_AGE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_registration_name_age)
            ],
            States.REG_GENDER: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_registration_gender)
            ],
            States.REG_CITY: [
                MessageHandler(filters.TEXT | filters.LOCATION, handle_registration_city)
            ],
            States.REG_BIO: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_registration_bio)
            ],
            States.REG_GOAL: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_registration_goal)
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
        per_message=False,
    )
    
    
    application.add_handler(registration_handler)
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("profile", profile_command))
    application.add_handler(CommandHandler("browse", browse_profiles_command))
    
    
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_quick_buttons))
    
    
    print("–ë–û–¢ –ó–ê–ü–£–©–ï–ù")
    
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
